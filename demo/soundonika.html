<!DOCTYPE html>
<!--suppress CssUnusedSymbol, CssRedundantUnit -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Soundonika Test</title>
    <style>
        body {
            font-family: sans-serif;
            background: #111;
            color: #eee;
            padding: 2rem;
            line-height: 1.5;
        }

        h1 {
            color: #8f8;
            margin-bottom: 0.5rem;
        }

        .section {
            margin: 2rem 0;
            padding: 1rem;
            border: 1px solid #333;
            border-radius: 8px;
        }

        .implementation-note {
            background: #1a1a2e;
            border-left: 4px solid #4a90e2;
            padding: 0.75rem;
            margin: 1rem 0;
            font-size: 0.9rem;
            border-radius: 0 4px 4px 0;
        }

        .implementation-note code {
            background: #2a2a3e;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #8fd3f4;
        }

        button {
            font-size: 1rem;
            margin: 0.25rem;
            padding: 0.6rem 1rem;
            background: #333;
            color: #eee;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #444;
        }

        button:disabled {
            background: #222;
            color: #666;
            cursor: not-allowed;
        }

        .status {
            margin: 1rem 0;
            padding: 0.5rem;
            background: #222;
            border-radius: 4px;
            font-family: monospace;
        }

        .progress {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #8f8, #4a4);
            width: 0%;
            transition: width 0.3s ease;
        }

        input[type="range"] {
            width: 200px;
            margin: 0 1rem;
        }

        .timing-demo {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .beat {
            height: 40px;
            background: #333;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.1s ease;
        }

        .beat.active {
            background: #8f8;
            color: #111;
        }
    </style>
</head>
<body>
<h1>üßÉ Enhanced Soundonika Test Suite</h1>
<p>Testing the new WebAudio-based scheduling architecture</p>

<!-- Initialization Section -->
<div class="section">
    <h2>üöÄ Initialization</h2>

    <div class="implementation-note">
        <strong>Implementation:</strong> Creates <code>AudioContext</code> and <code>SoundonikaEngine</code> instance.
        Calls <code>engine.init()</code> which executes <code>setupAudioGraph()</code>, <code>loadSampleIndex()</code>,
        <code>preloadSamples()</code>, and <code>setupSoundTypeMapping()</code>. Progress tracking uses
        <code>engine.getLoadingProgress()</code> polled every 100ms.
    </div>

    <button id="initBtn">Initialize Engine</button>
    <div class="status" id="initStatus">Not initialized</div>
    <div class="progress">
        <div class="progress-bar" id="progressBar"></div>
    </div>
</div>

<!-- Basic Controls -->
<div class="section">
    <h2>üéõÔ∏è Basic Controls</h2>

    <div class="implementation-note">
        <strong>Implementation:</strong> Volume control calls <code>engine.setVolume()</code> which updates
        <code>this.masterGain.gain.value</code> in the Web Audio graph. Mode switching uses
        <code>engine.setSoundMode()</code> to toggle between sample playback and synthesized click sounds.
    </div>

    <label>
        Volume: <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="0.8">
        <span id="volumeDisplay">0.8</span>
    </label>
    <br><br>
    <label>
        Mode:
        <select id="modeSelect">
            <option value="samples">Samples</option>
            <option value="clicks">Clicks</option>
        </select>
    </label>
</div>

<!-- Immediate Playback -->
<div class="section">
    <h2>üéµ Immediate Playback</h2>

    <div class="implementation-note">
        <strong>Implementation:</strong> Each button calls <code>engine.scheduleSound(ctx.currentTime, soundType, 1.0)</code>.
        The engine looks up the sound type in <code>this.soundTypeMap</code>, retrieves the corresponding
        <code>AudioBuffer</code> from <code>this.sampleBuffers</code>, creates a <code>BufferSource</code> node,
        and connects it through the audio graph for immediate playback.
    </div>

    <button onclick="testSound('kick')">Kick</button>
    <button onclick="testSound('snare')">Snare</button>
    <button onclick="testSound('hihat_closed')">Hi-Hat Closed</button>
    <button onclick="testSound('hihat_open')">Hi-Hat Open</button>
    <button onclick="testSound('perc')">Perc</button>
    <button onclick="testSound('shaker')">Shaker</button>
</div>

<!-- Scheduled Playback -->
<div class="section">
    <h2>‚è∞ Scheduled Playback</h2>

    <div class="implementation-note">
        <strong>Implementation:</strong> Uses Web Audio's precise timing by calling <code>engine.scheduleSound()</code>
        with future timestamps. The <code>source.start(when)</code> method schedules playback at exact audio
        context times. Velocity demo shows how the third parameter controls <code>gainNode.gain.value</code>
        for dynamic volume. Precision timing demonstrates sub-millisecond accuracy.
    </div>

    <button onclick="testScheduledSequence()">Play Scheduled Sequence</button>
    <button onclick="testVelocityDemo()">Velocity Demo</button>
    <button onclick="testPrecisionTiming()">Precision Timing Test</button>
    <div class="status" id="scheduleStatus">Ready for scheduling tests</div>
</div>

<!-- Rhythm Demo -->
<div class="section">
    <h2>ü•Å Rhythm Demo</h2>

    <div class="implementation-note">
        <strong>Implementation:</strong> Metronome uses <code>setInterval()</code> with BPM-calculated timing
        (60/BPM seconds per beat). Each tick calls <code>engine.scheduleSound()</code> with a small lookahead
        (<code>now + 0.01</code>) for precision. Accent beats use different sound types mapped in
        <code>setupSoundTypeMapping()</code>. Visual indicators update via DOM manipulation synchronized with audio.
    </div>

    <button onclick="startMetronome()">Start Metronome</button>
    <button onclick="stopMetronome()">Stop Metronome</button>
    <label>
        BPM: <input type="range" id="bpmSlider" min="60" max="180" value="120">
        <span id="bpmDisplay">120</span>
    </label>
    <div class="timing-demo">
        <div class="beat" id="beat1">1</div>
        <div class="beat" id="beat2">2</div>
        <div class="beat" id="beat3">3</div>
        <div class="beat" id="beat4">4</div>
    </div>
</div>

<!-- Performance Stats -->
<div class="section">
    <h2>üìä Performance Stats</h2>

    <div class="implementation-note">
        <strong>Implementation:</strong> Stats are gathered from engine methods: <code>getLoadedSampleCount()</code>
        returns <code>this.sampleBuffers.size</code>, <code>isReady()</code> checks <code>this.isInitialized</code>,
        and <code>ctx.currentTime</code> shows Web Audio's high-resolution timer. Auto-refresh uses
        <code>setInterval(updateStats, 1000)</code> for real-time monitoring.
    </div>

    <div class="status" id="statsDisplay">
        Loaded Samples: 0<br>
        Audio Context State: suspended<br>
        Current Time: 0.000s
    </div>
    <button onclick="updateStats()">Refresh Stats</button>
</div>

<script src="../js/soundonika.js"></script>
<script>
    let engine = null;
    let ctx = null;
    let metronomeInterval = null;
    let currentBeat = 0;
    let isMetronomeRunning = false; // Track the metronome state

    // UI Elements
    const initBtn = document.getElementById('initBtn');
    const initStatus = document.getElementById('initStatus');
    const progressBar = document.getElementById('progressBar');
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeDisplay = document.getElementById('volumeDisplay');
    const modeSelect = document.getElementById('modeSelect');
    const scheduleStatus = document.getElementById('scheduleStatus');
    const bpmSlider = document.getElementById('bpmSlider');
    const bpmDisplay = document.getElementById('bpmDisplay');
    const statsDisplay = document.getElementById('statsDisplay');

    // Initialize engine
    initBtn.addEventListener('click', async () => {
        try {
            initBtn.disabled = true;
            initStatus.textContent = 'Initializing...';

            ctx = new AudioContext();
            engine = new SoundonikaEngine(ctx);

            // Monitor loading progress
            const progressInterval = setInterval(() => {
                const progress = engine.getLoadingProgress();
                progressBar.style.width = (progress * 100) + '%';

                if (progress >= 1) {
                    clearInterval(progressInterval);
                }
            }, 100);

            await engine.init();

            initStatus.textContent = 'Engine initialized successfully!';
            initStatus.style.color = '#8f8';

            // Enable controls
            enableControls();
            updateStats();

        } catch (error) {
            initStatus.textContent = `Initialization failed: ${error.message}`;
            initStatus.style.color = '#f88';
            initBtn.disabled = false;
        }
    });

    // Volume control
    volumeSlider.addEventListener('input', () => {
        const volume = parseFloat(volumeSlider.value);
        volumeDisplay.textContent = volume.toFixed(1);
        if (engine) {
            engine.setVolume(volume);
        }
    });

    // Mode control
    modeSelect.addEventListener('change', () => {
        if (engine) {
            engine.setSoundMode(modeSelect.value);
        }
    });

    // BPM control - FIXED: Now restarts metronome if running
    bpmSlider.addEventListener('input', () => {
        bpmDisplay.textContent = bpmSlider.value;

        // If metronome is running, restart it with new BPM
        if (isMetronomeRunning) {
            stopMetronome();
            startMetronome();
        }
    });

    function enableControls() {
        volumeSlider.disabled = false;
        modeSelect.disabled = false;
        bpmSlider.disabled = false;
    }

    // Test functions
    function testSound(soundType) {
        if (!engine || !engine.isReady()) {
            alert('Engine not initialized. Click "Initialize Engine" first.');
            return;
        }

        engine.scheduleSound(ctx.currentTime, soundType, 1.0);
    }

    function testScheduledSequence() {
        if (!engine || !engine.isReady()) {
            alert('Engine not initialized.');
            return;
        }

        scheduleStatus.textContent = 'Playing scheduled sequence...';

        const startTime = ctx.currentTime + 0.1;
        const interval = 0.5; // 500 ms between sounds

        // Schedule a sequence: kick, snare, hihat, snare
        engine.scheduleSound(startTime, 'kick', 1.0);
        engine.scheduleSound(startTime + interval, 'snare', 0.8);
        engine.scheduleSound(startTime + interval * 2, 'hihat_closed', 0.6);
        engine.scheduleSound(startTime + interval * 3, 'snare', 0.8);

        setTimeout(() => {
            scheduleStatus.textContent = 'Sequence complete';
        }, interval * 4 * 1000);
    }

    function testVelocityDemo() {
        if (!engine || !engine.isReady()) {
            alert('Engine not initialized.');
            return;
        }

        scheduleStatus.textContent = 'Playing velocity demo...';

        const startTime = ctx.currentTime + 0.1;
        const velocities = [0.2, 0.4, 0.6, 0.8, 1.0];

        velocities.forEach((velocity, index) => {
            engine.scheduleSound(startTime + index * 0.3, 'kick', velocity);
        });

        setTimeout(() => {
            scheduleStatus.textContent = 'Velocity demo complete';
        }, velocities.length * 300);
    }

    function testPrecisionTiming() {
        if (!engine || !engine.isReady()) {
            alert('Engine not initialized.');
            return;
        }

        scheduleStatus.textContent = 'Testing precision timing...';

        const startTime = ctx.currentTime + 0.1;
        const interval = 0.1; // 100 ms - very tight timing

        // Schedule 10 rapid-fire sounds
        for (let i = 0; i < 10; i++) {
            engine.scheduleSound(startTime + i * interval, 'hihat_closed', 0.7);
        }

        setTimeout(() => {
            scheduleStatus.textContent = 'Precision timing test complete';
        }, 10 * interval * 1000);
    }

    function startMetronome() {
        if (!engine || !engine.isReady()) {
            alert('Engine not initialized.');
            return;
        }

        if (metronomeInterval) {
            stopMetronome();
        }

        const bpm = parseInt(bpmSlider.value);
        const interval = 60 / bpm; // seconds per beat

        currentBeat = 0;
        isMetronomeRunning = true; // Set a running state

        metronomeInterval = setInterval(() => {
            const now = ctx.currentTime;

            // Schedule the sound slightly ahead for precision
            if (currentBeat % 4 === 0) {
                engine.scheduleSound(now + 0.01, 'accent', 1.0);
            } else {
                engine.scheduleSound(now + 0.01, 'normal', 0.7);
            }

            // Update visual indicator
            updateBeatIndicator();
            currentBeat++;

        }, interval * 1000);
    }

    function stopMetronome() {
        if (metronomeInterval) {
            clearInterval(metronomeInterval);
            metronomeInterval = null;
            isMetronomeRunning = false; // Clear running state

            // Clear beat indicators
            for (let i = 1; i <= 4; i++) {
                document.getElementById(`beat${i}`).classList.remove('active');
            }
        }
    }

    function updateBeatIndicator() {
        // Clear all beats
        for (let i = 1; i <= 4; i++) {
            document.getElementById(`beat${i}`).classList.remove('active');
        }

        // Highlight current beat
        const beatNumber = (currentBeat % 4) + 1;
        document.getElementById(`beat${beatNumber}`).classList.add('active');
    }

    function updateStats() {
        if (!engine || !ctx) {
            statsDisplay.innerHTML = `
                    Loaded Samples: 0<br>
                    Audio Context State: not created<br>
                    Current Time: 0.000s
                `;
            return;
        }

        statsDisplay.innerHTML = `
                Loaded Samples: ${engine.getLoadedSampleCount()}<br>
                Audio Context State: ${ctx.state}<br>
                Current Time: ${ctx.currentTime.toFixed(3)}s<br>
                Engine Ready: ${engine.isReady()}<br>
                Current Mode: ${engine.getSoundMode()}<br>
                Volume: ${engine.getVolume().toFixed(2)}<br>
                Metronome: ${isMetronomeRunning ? 'Running' : 'Stopped'}<br>
                BPM: ${bpmSlider.value}
            `;
    }

    // Auto-update stats every second
    setInterval(updateStats, 1000);
</script>
</body>
</html>
